---
title: 费米加速代码及其理论推导
mathjax: true
date: 2024-08-29 08:57:18
tags:
- 天文 
- 科研
categories: 天文
cover:
---

# 代码

## 初始化
```
clc
close all
clear
%% Initialize
particle_position_save=[];
particle_velocity_save=[];
index_change=0;
```

## 生成云团
为了保证云团的密接，采用了以下算法：距离云团点最近的范围归为该云团。

```
%% Generate clouds position
R=5e6;
num=1e2;
cloud_position=Gen_cloud_pos(R,num);

%% Give a random velocity
v_norm=1e-4;
cloud_velocity=Gen_cloud_vel(v_norm,num);
```
## 生成粒子
```
%% Generate particle position
xe=0;
ye=0;
ze=0;
particle_position=[xe;ye;ze];

%% Generate particle velocity
gamma=1000;
particle_velocity=Gen_par_vel(gamma,1);
```
## 开始模拟
```
%% Simulation begin
while norm(particle_position)<R
    %% Determine which cloud is in
    index=find_minimum_distance(particle_position(:,end),cloud_position);
    %% Velocity Transform
    index_velocity=cloud_velocity(:,index);
    particle_velocity_transform=vel_tran(particle_velocity,index_velocity);
    %% Simulate the B
    timestep=100;
    while find_minimum_distance(particle_position(:,end),cloud_position)==index
        particle_position_save=[particle_position_save,particle_position];
        particle_velocity_save=[particle_velocity_save,vel_tran(particle_velocity_transform,-index_velocity)];
        particle_position=particle_position+timestep*particle_velocity_transform;
        rand1=rand*pi;
        rand2=rand;
        while rand2>sin(rand1)
            rand1=rand*pi;
            rand2=rand;
        end
        theta=3/1.7*sqrt(1-norm(particle_velocity_transform)^2)*rand()*cos(rand1);
        particle_velocity_transform=rotation(particle_velocity_transform,theta);
        if norm(particle_position)>R
            break
        end
    end
    index_change=index_change+1;
    %% Velocity Transform Back
    particle_velocity=particle_velocity_save(:,end);
end
```

```
figure()
plot3(particle_position_save(1,:),particle_position_save(2,:),particle_position_save(3,:))
xlim([-R,R])
ylim([-R,R])
zlim([-R,R])

figure()
gamma_save=zeros(1,size(particle_velocity_save,2));
for i=1:size(particle_velocity_save,2)
    gamma_save(i)=1/sqrt(1-norm(particle_velocity_save(:,i))^2);
end
plot(gamma_save)
```
```
%% Generate clouds position
function cloud_position=Gen_cloud_pos(R,num)
x=zeros(1,num);
y=zeros(1,num);
z=zeros(1,num);
for i=1:num
    x(i)=2*R*rand()-R;
    y(i)=2*R*rand()-R;
    z(i)=2*R*rand()-R;
    while x(i)^2+y(i)^2+z(i)^2>R^2
        x(i)=2*R*rand()-R;
        y(i)=2*R*rand()-R;
        z(i)=2*R*rand()-R;
    end
end
cloud_position=[x;y;z];
end

%% Give a random velocity
function cloud_velocity=Gen_cloud_vel(v_norm,num)
vx=2*rand(1,num)-1;
vy=2*rand(1,num)-1;
vz=2*rand(1,num)-1;
normalization=sqrt(vx.^2+vy.^2+vz.^2);
vx=vx./normalization*v_norm;
vy=vy./normalization*v_norm;
vz=vz./normalization*v_norm;

cloud_velocity=[vx;vy;vz];
end
```
```
%% Generate particle velocity
function particle_velocity=Gen_par_vel(gamma,num)
u_norm=sqrt(1-1/gamma^2);

ux=2*rand(1,num)-1;
uy=2*rand(1,num)-1;
uz=2*rand(1,num)-1;

normalization=sqrt(ux^2+uy^2+uz^2);
ux=ux/normalization*u_norm;
uy=uy/normalization*u_norm;
uz=uz/normalization*u_norm;

particle_velocity=[ux;uy;uz];
end
```
```
%% Determine which cloud is in
function index=find_minimum_distance(vec1,vec2)
r=(vec1(1)-vec2(1,:)).^2+(vec1(2)-vec2(2,:)).^2+(vec1(3)-vec2(3,:)).^2;
[~,index]=min(r');

end
%% Velocity Transform
function particle_velocity_transform=vel_tran(particle_velocity,index_velocity)
gamma_c=1/sqrt(1-norm(index_velocity)^2);
particle_velocity_transform=(particle_velocity/gamma_c+gamma_c/(gamma_c+1)*dot(particle_velocity,index_velocity)*index_velocity-index_velocity)/(1-dot(particle_velocity,index_velocity));
end
```
```
%% Position Transform
function particle_position_transform=pos_tran(particle_position,index_position,index_velocity)
particle_rel=particle_position-index_position;
vxc=vx(index);
vyc=vy(index);
vzc=vz(index);
index_velocity=[vxc;vyc;vzc];
gamma_c=1/sqrt(1-norm(index_velocity)^2);
Lambda=[
    v_norm^2+(gamma_c-1)*vxc^2,(gamma_c-1)*vxc*vyc,(gamma_c-1)*vxc*vzc;
    (gamma_c-1)*vxc*vyc,v_norm^2+(gamma_c-1)*vyc^2,(gamma_c-1)*vyc*vzc;
    (gamma_c-1)*vxc*vzc,(gamma_c-1)*vyc*vzc,v_norm^2+(gamma_c-1)*vzc^2]/v_norm^2;
particle_position_transform=Lambda*particle_rel;
end
```

```
%% B rotation
function v_rotated=rotation(v,theta)
random_vector = rand(3,1) - 0.5;
axis = random_vector / norm(random_vector);

K = [0, -axis(3), axis(2); axis(3), 0, -axis(1); -axis(2), axis(1), 0];
I = eye(3);
cos_theta = cos(theta);
sin_theta = sin(theta);
rotation_matrix = cos_theta * I + (1 - cos_theta) * (axis * axis') + sin_theta * K;

v_rotated = rotation_matrix * v;
end
```